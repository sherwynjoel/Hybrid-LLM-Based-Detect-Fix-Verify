"""Vulnerability detection using static analysis tools"""

import subprocess
import json
import re
from typing import List, Dict, Optional
from pathlib import Path
import tempfile
import os

from src.utils.code_parser import CodeParser
from src.utils.config import config


class VulnerabilityDetector:
    """Detect vulnerabilities using static analysis tools"""
    
    def __init__(self):
        self.parser = CodeParser()
        self.cwe_patterns = self._load_cwe_patterns()
    
    def detect(self, code: str, language: str, file_path: Optional[str] = None) -> List[Dict]:
        """Detect vulnerabilities in code"""
        vulnerabilities = []
        
        # Run language-specific static analyzers
        if language == 'python':
            vulnerabilities.extend(self._detect_python(code, file_path))
        elif language in ['cpp', 'c']:
            vulnerabilities.extend(self._detect_cpp(code, file_path))
        elif language == 'java':
            vulnerabilities.extend(self._detect_java(code, file_path))
        
        # Add CWE classification
        for vuln in vulnerabilities:
            vuln['cwe'] = self._classify_cwe(vuln, code, language)
        
        return vulnerabilities
    
    def _detect_python(self, code: str, file_path: Optional[str]) -> List[Dict]:
        """Detect vulnerabilities in Python code using Bandit and Semgrep"""
        vulnerabilities = []
        
        # Use Bandit for Python security issues
        try:
            bandit_results = self._run_bandit(code, file_path)
            vulnerabilities.extend(bandit_results)
        except Exception as e:
            print(f"Bandit detection failed: {e}")
        
        # Use Semgrep for pattern-based detection
        try:
            semgrep_results = self._run_semgrep(code, 'python', file_path)
            vulnerabilities.extend(semgrep_results)
        except Exception as e:
            print(f"Semgrep detection failed: {e}")
        
        # Always use pattern-based detection as fallback
        pattern_results = self._pattern_based_detection(code, 'python')
        vulnerabilities.extend(pattern_results)
        
        return vulnerabilities
    
    def _detect_cpp(self, code: str, file_path: Optional[str]) -> List[Dict]:
        """Detect vulnerabilities in C/C++ code"""
        vulnerabilities = []
        
        # Use Semgrep for C/C++
        try:
            semgrep_results = self._run_semgrep(code, 'cpp', file_path)
            vulnerabilities.extend(semgrep_results)
        except Exception as e:
            print(f"Semgrep detection failed: {e}")
        
        # Pattern-based detection for common C/C++ vulnerabilities
        vulnerabilities.extend(self._pattern_based_detection(code, 'cpp'))
        
        return vulnerabilities
    
    def _detect_java(self, code: str, file_path: Optional[str]) -> List[Dict]:
        """Detect vulnerabilities in Java code"""
        vulnerabilities = []
        
        # Use Semgrep for Java
        try:
            semgrep_results = self._run_semgrep(code, 'java', file_path)
            vulnerabilities.extend(semgrep_results)
        except Exception as e:
            print(f"Semgrep detection failed: {e}")
        
        # Pattern-based detection
        vulnerabilities.extend(self._pattern_based_detection(code, 'java'))
        
        return vulnerabilities
    
    def _run_bandit(self, code: str, file_path: Optional[str]) -> List[Dict]:
        """Run Bandit static analyzer on Python code"""
        vulnerabilities = []
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(code)
            temp_path = f.name
        
        try:
            # Run Bandit
            result = subprocess.run(
                ['bandit', '-f', 'json', '-q', temp_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0 or result.stdout:
                try:
                    bandit_data = json.loads(result.stdout)
                    for issue in bandit_data.get('results', []):
                        vulnerabilities.append({
                            'type': 'security',
                            'severity': issue.get('issue_severity', 'MEDIUM'),
                            'confidence': issue.get('issue_confidence', 'MEDIUM'),
                            'line': issue.get('line_number', 0),
                            'message': issue.get('issue_text', ''),
                            'test_id': issue.get('test_id', ''),
                            'tool': 'bandit'
                        })
                except json.JSONDecodeError:
                    pass
        except subprocess.TimeoutExpired:
            print("Bandit analysis timed out")
        except FileNotFoundError:
            print("Bandit not found. Install with: pip install bandit")
        finally:
            os.unlink(temp_path)
        
        return vulnerabilities
    
    def _run_semgrep(self, code: str, language: str, file_path: Optional[str]) -> List[Dict]:
        """Run Semgrep static analyzer"""
        vulnerabilities = []
        
        # Create temporary file
        ext_map = {'python': '.py', 'cpp': '.cpp', 'java': '.java'}
        ext = ext_map.get(language, '.txt')
        
        with tempfile.NamedTemporaryFile(mode='w', suffix=ext, delete=False) as f:
            f.write(code)
            temp_path = f.name
        
        try:
            # Run Semgrep with security rules
            result = subprocess.run(
                ['semgrep', '--config', 'auto', '--json', temp_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout:
                try:
                    semgrep_data = json.loads(result.stdout)
                    for result_item in semgrep_data.get('results', []):
                        vulnerabilities.append({
                            'type': 'security',
                            'severity': result_item.get('extra', {}).get('severity', 'INFO'),
                            'line': result_item.get('start', {}).get('line', 0),
                            'message': result_item.get('message', ''),
                            'rule_id': result_item.get('check_id', ''),
                            'tool': 'semgrep'
                        })
                except json.JSONDecodeError:
                    pass
        except subprocess.TimeoutExpired:
            print("Semgrep analysis timed out")
        except FileNotFoundError:
            print("Semgrep not found. Install with: pip install semgrep")
        finally:
            os.unlink(temp_path)
        
        return vulnerabilities
    
    def _pattern_based_detection(self, code: str, language: str) -> List[Dict]:
        """Pattern-based vulnerability detection"""
        vulnerabilities = []
        lines = code.split('\n')
        
        # SQL Injection patterns
        sql_patterns = [
            (r'execute\s*\([^)]*\+', 'SQL Injection', 'HIGH'),
            (r'query\s*\([^)]*\+', 'SQL Injection', 'HIGH'),
            (r'format\s*\([^)]*%s', 'SQL Injection', 'MEDIUM'),
            (r'SELECT.*\+.*FROM', 'SQL Injection', 'HIGH'),
            (r'WHERE.*=.*\+', 'SQL Injection', 'HIGH'),
            (r'["\'].*\+.*username', 'SQL Injection', 'HIGH'),  # String concatenation with user input
            (r'=.*["\'].*\+.*["\']', 'SQL Injection', 'HIGH'),  # Assignment with concatenation
        ]
        
        # Command Injection patterns
        cmd_injection_patterns = [
            (r'subprocess\.(call|run|Popen)\s*\([^)]*\+', 'Command Injection', 'CRITICAL'),
            (r'subprocess\.call\s*\([^)]*shell\s*=\s*True', 'Command Injection', 'CRITICAL'),
            (r'os\.system\s*\([^)]*\+', 'Command Injection', 'CRITICAL'),
        ]
        
        # Path Traversal patterns
        path_traversal_patterns = [
            (r'open\s*\([^)]*\+.*filename', 'Path Traversal', 'HIGH'),
            (r'file_path\s*=\s*["\'][^"\']*\+.*filename', 'Path Traversal', 'HIGH'),
        ]
        
        # Insecure Deserialization patterns
        deserialization_patterns = [
            (r'pickle\.loads\s*\(', 'Insecure Deserialization', 'CRITICAL'),
            (r'pickle\.load\s*\(', 'Insecure Deserialization', 'CRITICAL'),
        ]
        
        # Hardcoded credentials patterns
        credential_patterns = [
            (r'password\s*=\s*["\'][^"\']+["\']', 'Hardcoded Credentials', 'HIGH'),
            (r'username\s*=\s*["\']admin["\']', 'Hardcoded Credentials', 'HIGH'),
        ]
        
        # Weak cryptography patterns
        crypto_patterns = [
            (r'hashlib\.md5\s*\(', 'Weak Cryptography', 'HIGH'),
        ]
        
        # Information disclosure patterns
        info_disclosure_patterns = [
            (r'os\.environ\.get\s*\([^)]*SECRET', 'Information Disclosure', 'MEDIUM'),
            (r'os\.environ\.get\s*\([^)]*API_KEY', 'Information Disclosure', 'MEDIUM'),
        ]
        
        # Insecure random patterns
        random_patterns = [
            (r'token\s*=\s*random\.randint', 'Insecure Random', 'MEDIUM'),
        ]
        
        # Missing input validation patterns
        validation_patterns = [
            (r'balance\s*-=\s*amount\s*#.*negative', 'Missing Input Validation', 'MEDIUM'),
        ]
        
        # Debug mode patterns
        debug_patterns = [
            (r'app\.run\s*\([^)]*debug\s*=\s*True', 'Debug Mode in Production', 'MEDIUM'),
        ]
        
        # Buffer overflow patterns (C/C++)
        if language == 'cpp':
            buffer_patterns = [
                (r'strcpy\s*\(', 'Buffer Overflow', 'HIGH'),
                (r'strcat\s*\(', 'Buffer Overflow', 'HIGH'),
                (r'gets\s*\(', 'Buffer Overflow', 'CRITICAL'),
                (r'sprintf\s*\([^,]+,\s*[^,]+\)', 'Format String', 'HIGH'),
            ]
            sql_patterns.extend(buffer_patterns)
        
        # XSS patterns
        xss_patterns = [
            (r'innerHTML\s*=', 'XSS', 'HIGH'),
            (r'document\.write\s*\(', 'XSS', 'HIGH'),
            (r'return\s+f?["\'][^"\']*\{query\}', 'XSS', 'MEDIUM'),
            (r'<h1>.*\{query\}', 'XSS', 'MEDIUM'),
        ]
        
        # Combine all patterns
        all_patterns = (sql_patterns + cmd_injection_patterns + path_traversal_patterns + 
                       deserialization_patterns + credential_patterns + crypto_patterns +
                       info_disclosure_patterns + random_patterns + validation_patterns +
                       debug_patterns + xss_patterns)
        
        for line_num, line in enumerate(lines, 1):
            for pattern, vuln_type, severity in all_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': severity,
                        'line': line_num,
                        'message': f'Potential {vuln_type} vulnerability',
                        'code': line.strip(),
                        'tool': 'pattern'
                    })
        
        return vulnerabilities
    
    def _classify_cwe(self, vulnerability: Dict, code: str, language: str) -> str:
        """Classify vulnerability into CWE category"""
        vuln_type = vulnerability.get('type', '').lower()
        message = vulnerability.get('message', '').lower()
        
        # CWE classification mapping
        if 'sql injection' in vuln_type or 'sql injection' in message:
            return 'CWE-89'
        elif 'xss' in vuln_type or 'cross-site' in message:
            return 'CWE-79'
        elif 'buffer overflow' in vuln_type or 'buffer' in message:
            return 'CWE-119'
        elif 'command injection' in vuln_type or 'command' in message:
            return 'CWE-78'
        elif 'path traversal' in vuln_type or 'path' in message:
            return 'CWE-22'
        elif 'input validation' in message:
            return 'CWE-20'
        else:
            return 'CWE-OTHER'
    
    def _load_cwe_patterns(self) -> Dict:
        """Load CWE-specific detection patterns"""
        return {
            'CWE-79': [r'innerHTML', r'document\.write'],
            'CWE-89': [r'execute\s*\(.*\+', r'query\s*\(.*\+'],
            'CWE-78': [r'eval\s*\(', r'system\s*\('],
            'CWE-22': [r'\.\./', r'\.\.\\\\'],
            'CWE-119': [r'strcpy', r'strcat', r'gets'],
            'CWE-20': [r'input\s*\(', r'raw_input\s*\(']
        }
    
    def extract_context(self, code: str, vulnerability: Dict, context_lines: int = 5) -> Dict:
        """Extract code context around vulnerability"""
        line_num = vulnerability.get('line', 0)
        lines = code.split('\n')
        
        start = max(0, line_num - context_lines - 1)
        end = min(len(lines), line_num + context_lines)
        
        context_code = '\n'.join(lines[start:end])
        
        return {
            **vulnerability,
            'context': context_code,
            'context_start': start + 1,
            'context_end': end
        }

